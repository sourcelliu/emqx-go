// This file defines the gRPC service and messages for inter-node communication
// in the EMQX-Go cluster. It covers node management, routing, message
// forwarding, and synchronization of state.

syntax = "proto3";

package proto;
option go_package = "github.com/turtacn/emqx-go/pkg/proto/cluster;clusterpb";

// NodeInfo contains essential information about a single node in the cluster.
// This message is used for node discovery, status reporting, and cluster management.
message NodeInfo {
  // node_id is a unique identifier for the node, typically a hostname or a
  // generated UUID.
  string node_id = 1;
  // address is the network address (e.g., "ip:port") where the node's gRPC
  // service is listening.
  string address = 2;
  // version is the semantic version of the EMQX application running on the node.
  string version = 3;
  // uptime is the duration in seconds that the node has been running.
  int64 uptime = 4;
  // status represents the current operational state of the node (e.g., 1 for
  // running, 2 for offline, 3 for starting).
  int32 status = 5;
  // last_seen is a Unix timestamp indicating the last time the node was observed
  // to be active.
  int64 last_seen = 6;
}

// JoinRequest is sent by a node wishing to become a member of the cluster.
message JoinRequest {
  // node contains the information about the joining node.
  NodeInfo node = 1;
  // token is an optional authentication token for securing the cluster.
  string token = 2;
  // timestamp is the Unix timestamp of when the join request was initiated.
  int64 timestamp = 3;
}

// JoinResponse is sent by a cluster member in response to a JoinRequest.
message JoinResponse {
  // success indicates whether the join request was accepted.
  bool success = 1;
  // message provides a human-readable reason for the success or failure of the
  // join operation.
  string message = 2;
  // cluster_nodes is a list of all nodes that are currently members of the
  // cluster.
  repeated NodeInfo cluster_nodes = 3;
  // cluster_id is a unique identifier for the entire cluster.
  string cluster_id = 4;
}

// LeaveRequest is sent by a node that intends to gracefully exit the cluster.
message LeaveRequest {
  // node_id is the unique identifier of the node that is leaving.
  string node_id = 1;
  // force indicates whether the departure should be forced, which can be used
  // to remove a non-responsive node.
  bool force = 2;
}

// LeaveResponse is the acknowledgment for a LeaveRequest.
message LeaveResponse {
  // success indicates whether the leave operation was processed successfully.
  bool success = 1;
  // message provides details about the result of the leave operation.
  string message = 2;
  // remaining_nodes contains the list of nodes left in the cluster after the
  // departure.
  repeated NodeInfo remaining_nodes = 3;
}

// SyncNodeStatusRequest is periodically sent by nodes to exchange their status
// and view of the cluster, ensuring eventual consistency.
message SyncNodeStatusRequest {
  // node is the information of the node initiating the synchronization.
  NodeInfo node = 1;
  // known_nodes is the list of nodes that the sender is currently aware of.
  repeated NodeInfo known_nodes = 2;
}

// SyncNodeStatusResponse is the response to a status synchronization request.
message SyncNodeStatusResponse {
  // success indicates whether the synchronization was successful.
  bool success = 1;
  // message provides details about the result of the synchronization.
  string message = 2;
  // all_nodes contains the responding node's complete view of the cluster,
  // allowing the requester to update its own list.
  repeated NodeInfo all_nodes = 3;
}

// Subscription represents a single client's subscription to a topic, which
// needs to be shared across the cluster.
message Subscription {
  // client_id is the unique identifier of the MQTT client that made the
  // subscription.
  string client_id = 1;
  // topic_filter is the MQTT topic filter (e.g., "a/b/#") for the subscription.
  string topic_filter = 2;
  // qos is the Quality of Service level requested for the subscription.
  int32 qos = 3;
  // no_local is a boolean flag indicating that the subscriber should not
  // receive messages published by its own client ID.
  bool no_local = 4;
  // retain_as_published is a boolean flag indicating if the retain flag of
  // incoming messages should be preserved when forwarding them.
  bool retain_as_published = 5;
  // retain_handling specifies the policy for sending retained messages upon
  // subscription.
  int32 retain_handling = 6;
}

// SyncSubscriptionsRequest is used to share subscription information between
// nodes.
message SyncSubscriptionsRequest {
  // node_id is the identifier of the node sending the subscription information.
  string node_id = 1;
  // subscriptions is the list of subscriptions to be shared.
  repeated Subscription subscriptions = 2;
  // full_sync indicates whether this request contains the entire subscription
  // set (true) or just an incremental update (false).
  bool full_sync = 3;
}

// SyncSubscriptionsResponse is the acknowledgment for a subscription sync.
message SyncSubscriptionsResponse {
  // success indicates if the subscriptions were received and processed.
  bool success = 1;
  // message provides details about the outcome.
  string message = 2;
  // received_count is the number of subscriptions that were processed from the
  // request.
  int32 received_count = 3;
}

// PublishForward is a message used to wrap an MQTT PUBLISH packet for
// forwarding to another node in the cluster.
message PublishForward {
  // message_id is a unique identifier for this forwarded message.
  string message_id = 1;
  // topic is the MQTT topic to which the message was published.
  string topic = 2;
  // payload is the binary content of the message.
  bytes payload = 3;
  // qos is the Quality of Service level of the original message.
  int32 qos = 4;
  // retain indicates if this was a retained message.
  bool retain = 5;
  // dup is the duplicate flag from the original MQTT packet.
  bool dup = 6;
  // from_node is the ID of the node where the message was originally received.
  string from_node = 7;
  // from_client is the ID of the MQTT client that published the message.
  string from_client = 8;
  // timestamp is the Unix timestamp of when the message was originally
  // published.
  int64 timestamp = 9;
  // user_properties are the user-defined properties from the MQTT 5 packet.
  map<string, bytes> user_properties = 10;
}

// ForwardAck is the acknowledgment sent in response to a PublishForward message.
message ForwardAck {
  // message_id is the ID of the message being acknowledged.
  string message_id = 1;
  // success indicates if the message was successfully received and queued for
  // local delivery.
  bool success = 2;
  // message provides details about the forwarding outcome.
  string message = 3;
  // to_node is the ID of the node that is acknowledging the message.
  string to_node = 4;
}

// Route represents the routing information for a single topic filter, mapping it
// to the nodes that have subscribers for it.
message Route {
  // topic is the topic filter for which this route provides information.
  string topic = 1;
  // node_ids is a list of unique node identifiers that have clients subscribed
  // to this topic.
  repeated string node_ids = 2;
  // update_time is the Unix timestamp of the last modification to this route.
  int64 update_time = 3;
}

// BatchUpdateRoutesRequest is used to send multiple routing updates in a single
// gRPC call for efficiency.
message BatchUpdateRoutesRequest {
  // routes is a list of routing information to be added, updated, or removed.
  repeated Route routes = 1;
  // op_type specifies the operation to perform, such as "add", "delete", or
  // "update".
  string op_type = 2;
  // from_node is the ID of the node that initiated this routing update.
  string from_node = 3;
}

// BatchUpdateRoutesResponse is the acknowledgment for a routing update request.
message BatchUpdateRoutesResponse {
  // success indicates if the routing update was processed successfully.
  bool success = 1;
  // message provides details about the outcome.
  string message = 2;
  // updated_count is the number of routes that were successfully processed.
  int32 updated_count = 3;
}

// SyncConfigRequest is sent to synchronize configuration settings across the
// cluster.
message SyncConfigRequest {
  // node_id is the identifier of the node sending the request.
  string node_id = 1;
  // config_key is the specific configuration key to synchronize. If empty, it
  // implies a request for all configuration.
  string config_key = 2;
  // configs is a map of configuration key-value pairs to be synchronized.
  map<string, string> configs = 3;
}

// SyncConfigResponse is the response to a configuration synchronization request.
message SyncConfigResponse {
  // success indicates if the configuration was synchronized successfully.
  bool success = 1;
  // message provides details about the outcome.
  string message = 2;
  // configs contains the full configuration map, typically returned only in
  // response to a full sync request.
  map<string, string> configs = 3;
}

// ClusterStatsRequest is sent to query performance and usage statistics from
// nodes in the cluster.
message ClusterStatsRequest {
  // node_id specifies a particular node to get stats from. If empty, stats are
  // requested from all nodes.
  string node_id = 1;
  // metrics is a list of specific metric names to retrieve. If empty, all
  // available metrics are returned.
  repeated string metrics = 2;
}

// NodeStats contains a set of statistical metrics for a single node.
message NodeStats {
  // node_id is the identifier of the node these statistics belong to.
  string node_id = 1;
  // metrics is a map of metric names to their integer values (e.g.,
  // "messages.in" -> 1024).
  map<string, int64> metrics = 2;
  // timestamp is the Unix timestamp of when these stats were collected.
  int64 timestamp = 3;
}

// ClusterStatsResponse is the response to a statistics request.
message ClusterStatsResponse {
  // success indicates if the stats request was successfully processed.
  bool success = 1;
  // message provides details about the outcome.
  string message = 2;
  // node_stats is a list containing the statistics from each queried node.
  repeated NodeStats node_stats = 3;
  // timestamp is the Unix timestamp of when the cluster-wide stats were
  // aggregated.
  int64 timestamp = 4;
}

// ClusterService defines the set of RPCs for managing and operating the EMQX-Go
// cluster. All inter-node communication happens through this service.
service ClusterService {
  // Join allows a new node to request membership in the cluster.
  rpc Join(JoinRequest) returns (JoinResponse);

  // Leave allows a node to gracefully exit the cluster.
  rpc Leave(LeaveRequest) returns (LeaveResponse);

  // SyncNodeStatus is used for periodic health checks and state synchronization
  // between nodes.
  rpc SyncNodeStatus(SyncNodeStatusRequest) returns (SyncNodeStatusResponse);

  // SyncSubscriptions shares client subscription information across the cluster
  // to enable global message routing.
  rpc SyncSubscriptions(SyncSubscriptionsRequest) returns (SyncSubscriptionsResponse);

  // ForwardPublish forwards an MQTT message from one node to another that has
  // subscribers for the message's topic.
  rpc ForwardPublish(PublishForward) returns (ForwardAck);

  // BatchUpdateRoutes efficiently updates the distributed routing table across
  // the cluster.
  rpc BatchUpdateRoutes(BatchUpdateRoutesRequest) returns (BatchUpdateRoutesResponse);

  // SyncConfig ensures that configuration settings are consistent across all
  // nodes in the cluster.
  rpc SyncConfig(SyncConfigRequest) returns (SyncConfigResponse);

  // GetClusterStats provides a way to retrieve operational metrics from the
  // entire cluster or specific nodes.
  rpc GetClusterStats(ClusterStatsRequest) returns (ClusterStatsResponse);
}